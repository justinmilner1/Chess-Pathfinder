{"ast":null,"code":"import _objectSpread from\"/Users/justinmilner/Documents/GitHub/Pathfinding/pathfindingapp/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _classCallCheck from\"/Users/justinmilner/Documents/GitHub/Pathfinding/pathfindingapp/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/Users/justinmilner/Documents/GitHub/Pathfinding/pathfindingapp/node_modules/@babel/runtime/helpers/esm/createClass\";import _possibleConstructorReturn from\"/Users/justinmilner/Documents/GitHub/Pathfinding/pathfindingapp/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";import _getPrototypeOf from\"/Users/justinmilner/Documents/GitHub/Pathfinding/pathfindingapp/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";import _inherits from\"/Users/justinmilner/Documents/GitHub/Pathfinding/pathfindingapp/node_modules/@babel/runtime/helpers/esm/inherits\";import React,{Component}from\"react\";import Node from\"./Node.jsx\";import{dijkstra,getNodesInShortestPathOrder}from\"../algorithms/dijkstra\";import\"./PathfindingVisualizer.css\";var START_NODE_ROW=10;var START_NODE_COL=11;var FINISH_NODE_ROW=10;var FINISH_NODE_COL=39;var PathfindingVisualizer=/*#__PURE__*/function(_Component){_inherits(PathfindingVisualizer,_Component);function PathfindingVisualizer(){var _this;_classCallCheck(this,PathfindingVisualizer);_this=_possibleConstructorReturn(this,_getPrototypeOf(PathfindingVisualizer).call(this));_this.state={grid:[],mouseIsPressed:false};return _this;}_createClass(PathfindingVisualizer,[{key:\"componentDidMount\",value:function componentDidMount(){var grid=getInitialGrid();this.setState({grid:grid});}},{key:\"handleMouseDown\",value:function handleMouseDown(row,col){var newGrid=getNewGridWithWallToggled(this.state.grid,row,col);this.setState({grid:newGrid,mouseIsPressed:true});}},{key:\"handleMouseEnter\",value:function handleMouseEnter(row,col){if(!this.state.mouseIsPressed)return;var newGrid=getNewGridWithWallToggled(this.state.grid,row,col);this.setState({grid:newGrid});}},{key:\"handleMouseUp\",value:function handleMouseUp(){this.setState({mouseIsPressed:false});}},{key:\"animateDijkstra\",value:function animateDijkstra(visitedNodesInOrder,nodesInShortestPathOrder){var _this2=this;var _loop=function _loop(i){if(i===visitedNodesInOrder.length){setTimeout(function(){_this2.animateShortestPath(nodesInShortestPathOrder);},_this2.props.onAlgoSpeed*i);//change 10 to algoSpeedVar\nreturn{v:void 0};}setTimeout(function(){var node=visitedNodesInOrder[i];document.getElementById(\"node-\".concat(node.row,\"-\").concat(node.col)).className=\"node node-visited\";},_this2.props.onAlgoSpeed*i);//change 10 to algoSpeedVar\n};for(var i=0;i<=visitedNodesInOrder.length;i++){var _ret=_loop(i);if(typeof _ret===\"object\")return _ret.v;}}},{key:\"animateShortestPath\",value:function animateShortestPath(nodesInShortestPathOrder){var _this3=this;var _loop2=function _loop2(i){setTimeout(function(){var node=nodesInShortestPathOrder[i];document.getElementById(\"node-\".concat(node.row,\"-\").concat(node.col)).className=\"node node-shortest-path\";},_this3.props.onShortestPathSpeed*i);//change 50 to shortestPathVar\n};for(var i=0;i<nodesInShortestPathOrder.length;i++){_loop2(i);}}},{key:\"visualizeDijkstra\",value:function visualizeDijkstra(){var grid=this.state.grid;var startNode=grid[START_NODE_ROW][START_NODE_COL];var finishNode=grid[FINISH_NODE_ROW][FINISH_NODE_COL];var visitedNodesInOrder=dijkstra(grid,startNode,finishNode);var nodesInShortestPathOrder=getNodesInShortestPathOrder(finishNode);this.animateDijkstra(visitedNodesInOrder,nodesInShortestPathOrder);}},{key:\"getAlgorithm\",value:function getAlgorithm(){return this.props.algorithm;}},{key:\"render\",value:function render(){var _this4=this;var _this$state=this.state,grid=_this$state.grid,mouseIsPressed=_this$state.mouseIsPressed;return React.createElement(\"div\",null,React.createElement(\"button\",{className:\"btn btn-primary btn-sm m-2\",onClick:function onClick(){return _this4.visualizeDijkstra();}},\"Visualize \",this.props.onAlgo,\" with \",this.props.onPiece2),React.createElement(\"div\",{className:\"grid\"},grid.map(function(row,rowIdx){return React.createElement(\"div\",{key:rowIdx},row.map(function(node,nodeIdx){var row=node.row,col=node.col,isFinish=node.isFinish,isStart=node.isStart,isWall=node.isWall;return React.createElement(Node,{key:nodeIdx,col:col,isFinish:isFinish,isStart:isStart,isWall:isWall,mouseIsPressed:mouseIsPressed,onMouseDown:function onMouseDown(row,col){return _this4.handleMouseDown(row,col);},onMouseEnter:function onMouseEnter(row,col){return _this4.handleMouseEnter(row,col);},onMouseUp:function onMouseUp(){return _this4.handleMouseUp();},row:row});}));})));}}]);return PathfindingVisualizer;}(Component);export{PathfindingVisualizer as default};var getInitialGrid=function getInitialGrid(){var grid=[];for(var row=0;row<20;row++){var currentRow=[];for(var col=0;col<50;col++){currentRow.push(createNode(col,row));}grid.push(currentRow);}return grid;};var createNode=function createNode(col,row){return{col:col,row:row,isStart:row===START_NODE_ROW&&col===START_NODE_COL,isFinish:row===FINISH_NODE_ROW&&col===FINISH_NODE_COL,distance:Infinity,isVisited:false,isWall:false,previousNode:null};};var getNewGridWithWallToggled=function getNewGridWithWallToggled(grid,row,col){var newGrid=grid.slice();var node=newGrid[row][col];var newNode=_objectSpread({},node,{isWall:!node.isWall});newGrid[row][col]=newNode;return newGrid;};","map":{"version":3,"sources":["/Users/justinmilner/Documents/GitHub/Pathfinding/pathfindingapp/src/components/PathfindingVisualizer.jsx"],"names":["React","Component","Node","dijkstra","getNodesInShortestPathOrder","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","PathfindingVisualizer","state","grid","mouseIsPressed","getInitialGrid","setState","row","col","newGrid","getNewGridWithWallToggled","visitedNodesInOrder","nodesInShortestPathOrder","i","length","setTimeout","animateShortestPath","props","onAlgoSpeed","node","document","getElementById","className","onShortestPathSpeed","startNode","finishNode","animateDijkstra","algorithm","visualizeDijkstra","onAlgo","onPiece2","map","rowIdx","nodeIdx","isFinish","isStart","isWall","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","push","createNode","distance","Infinity","isVisited","previousNode","slice","newNode"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport Node from \"./Node.jsx\";\nimport { dijkstra, getNodesInShortestPathOrder } from \"../algorithms/dijkstra\";\n\nimport \"./PathfindingVisualizer.css\";\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 11;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 39;\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false\n    };\n  }\n\n  componentDidMount() {\n    const grid = getInitialGrid();\n    this.setState({ grid });\n  }\n\n  handleMouseDown(row, col) {\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({ grid: newGrid, mouseIsPressed: true });\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.mouseIsPressed) return;\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({ grid: newGrid });\n  }\n\n  handleMouseUp() {\n    this.setState({ mouseIsPressed: false });\n  }\n\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, this.props.onAlgoSpeed * i); //change 10 to algoSpeedVar\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, this.props.onAlgoSpeed * i); //change 10 to algoSpeedVar\n    }\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, this.props.onShortestPathSpeed * i); //change 50 to shortestPathVar\n    }\n  }\n\n  visualizeDijkstra() {\n    const { grid } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  getAlgorithm() {\n    return this.props.algorithm;\n  }\n\n  render() {\n    const { grid, mouseIsPressed } = this.state;\n\n    return (\n      <div>\n        <button\n          className=\"btn btn-primary btn-sm m-2\"\n          onClick={() => this.visualizeDijkstra()}\n        >\n          Visualize {this.props.onAlgo} with {this.props.onPiece2}\n        </button>\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const { row, col, isFinish, isStart, isWall } = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseIsPressed={mouseIsPressed}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                      row={row}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  }\n}\n\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row < 20; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 50; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null\n  };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n"]},"metadata":{},"sourceType":"module"}